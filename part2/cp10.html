<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第十章 编译期if - C++ 17 The Complete Guide</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../part1/index.html">第一部分 基本语言特性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../part1/cp1.html">第一章 结构化绑定</a></li><li class="chapter-item "><a href="../part1/cp2.html">第二章 带初始化的if和switch</a></li><li class="chapter-item "><a href="../part1/cp3.html">第三章 内联变量</a></li><li class="chapter-item "><a href="../part1/cp4.html">第四章 聚合扩展</a></li><li class="chapter-item "><a href="../part1/cp5.html">第五章 强制拷贝消除或者传递未具体化对象</a></li><li class="chapter-item "><a href="../part1/cp6.html">第六章 Lambda扩展</a></li><li class="chapter-item "><a href="../part1/cp7.html">第七章 新属性和属性相关特性</a></li><li class="chapter-item "><a href="../part1/cp8.html">第八章 其他语言特性</a></li></ol></li><li class="chapter-item expanded "><a href="../part2/index.html">第二部分 模板特性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../part2/cp9.html">第九章 类模板参数推导</a></li><li class="chapter-item expanded "><a href="../part2/cp10.html" class="active">第十章 编译期if</a></li><li class="chapter-item "><a href="../part2/cp11.html">第十一章 折叠表达式</a></li><li class="chapter-item "><a href="../part2/cp12.html">第十二章 String作为模板参数</a></li><li class="chapter-item "><a href="../part2/cp13.html">第十三章 auto作为模板参数占位符</a></li><li class="chapter-item "><a href="../part2/cp14.html">第十四章 扩展Using声明</a></li></ol></li><li class="chapter-item expanded "><div>第三部分 新的标准库组件</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../part3/cp15.html">第十五章 std::optional&lt;&gt;</a></li><li class="chapter-item "><div>第十六章 std::variant&lt;&gt;</div></li><li class="chapter-item "><div>第十七章 std::any</div></li><li class="chapter-item "><div>第十八章 std::byte</div></li><li class="chapter-item "><div>第十九章 String View</div></li><li class="chapter-item "><div>第二十章 文件系统库</div></li></ol></li><li class="chapter-item expanded "><div>第四部分 标准库扩展和修改</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>第二十一章 Type Trait扩展</div></li><li class="chapter-item "><div>第二十二章 并行STL算法</div></li><li class="chapter-item "><div>第二十三章 子字符串和子序列搜索</div></li><li class="chapter-item "><div>第二十四章 其他工具函数和算法</div></li><li class="chapter-item "><div>第二十五章 容器扩展</div></li><li class="chapter-item "><div>第二十六章 多线程和兵法</div></li></ol></li><li class="chapter-item expanded "><div>第五部分 专业工具</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>第二十七章 多态类型资源（PMR）</div></li><li class="chapter-item "><div>第二十八章 对齐数据上的new和delete</div></li><li class="chapter-item "><div>第二十九章 其他专业库的改动</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ 17 The Complete Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CnTransGroup/Cpp17TheCompleteGuideChinese" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第十章-编译期if"><a class="header" href="#第十章-编译期if">第十章 编译期if</a></h1>
<p>通过语法<code>if constexpr(...)</code>，编译器使用编译时表达式在编译时决定是否使用then部分或者else部分。如果任一部分被抛弃，那部分代码就不会生成。但是，这不意味着被抛弃的部分完全被忽略了。它将像未使用模板的代码一样进行检查。
比如：</p>
<pre><code class="language-cpp">#include &lt;string&gt;
template &lt;typename T&gt;
std::string asString(T x)
{
    if constexpr(std::is_same_v&lt;T, std::string&gt;) {
        return x; // statement invalid, if no conversion to string
    }
    else if constexpr(std::is_arithmetic_v&lt;T&gt;) {
        return std::to_string(x); // statement invalid, if x is not numeric
    }
    else {
        return std::string(x); // statement invalid, if no conversion to string
    }
}
</code></pre>
<p>这里我们用到了编译器if的特性。它在编译时决定我们是只返回一个字符串，还是说要调<code>std::to_string()</code>把数组转称字符串，又或者把传进来的参数转成<code>std::string</code>。因为无效的调用会被抛弃，下面的代码都可以编译：</p>
<pre><code class="language-cpp">#include &quot;ifcomptime.hpp&quot;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; asString(42) &lt;&lt; '\n';
    std::cout &lt;&lt; asString(std::string(&quot;hello&quot;)) &lt;&lt; '\n';
    std::cout &lt;&lt; asString(&quot;hello&quot;) &lt;&lt; '\n';
}
</code></pre>
<h2 id="101-存在编译期if的动机"><a class="header" href="#101-存在编译期if的动机">10.1 存在编译期if的动机</a></h2>
<p>如果刚刚的例子中，我们用运行时if：</p>
<pre><code class="language-cpp"> #include &lt;string&gt;
template &lt;typename T&gt;
std::string asString(T x)
{
    if (std::is_same_v&lt;T, std::string&gt;) {
        return x; // ERROR, if no conversion to string
    }
    else if (std::is_numeric_v&lt;T&gt;) {
        return std::to_string(x); // ERROR, if x is not numeric
    }
    else {
        return std::string(x); // ERROR, if no conversion to string
    }
}
</code></pre>
<p>对应的调用代码肯定不能编译。这是因为函数模板有个规则，要么全编，要么完全不编。if的条件检查是一个运行时行为。即使编译期就知道条件一定是个false，then也必须编。所以，当传递一个<code>std::string</code>或者字符串字面值的时候，编译就出错了，因为对于传入的参数调用<code>std::string</code>是无效的。当传递数值时，编译也出错，因为第一个和第三个返回语句是无效的。</p>
<p>注意，仅当使用编译期if的时候，then或者else没有被用到的才会被丢弃：</p>
<ul>
<li>当传<code>std::string</code>时，第一个if的else部分被丢弃</li>
<li>当传一个数值时，第一个if的then部分和最后的else被丢弃</li>
<li>当传递一个字符串字面值时（即类型<code>const char*</code>），then和第二个if被丢弃</li>
</ul>
<p>注意，被丢弃的语句不是说被忽略了。只是说当依赖模板参数时，它不会被实例化。语法必须正确，不依赖模板参数的调用也必须正确。事实上，在第一个翻译阶段（<strong>definition time</strong>）执行时，编译器会检查语法正确与否，使用的所有名字是否都不依赖模板参数。所有<code>static_assert</code>也必须正确，即使该分支不会被编译。比如</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
void foo(T t)
{
    if constexpr(std::is_integral_v&lt;T&gt;) {
        if (t &gt; 0) {
            foo(t-1); // OK
        }
    }
    else {
        undeclared(t); // error if not declared and not discarded (i.e., T is not integral)
        undeclared(); // error if not declared (even if discarded)
        static_assert(false, &quot;no integral&quot;); // always asserts (even if discarded)
    }
}
</code></pre>
<p>只要是符合标准的编译器，这个例子都不会被编译，原因有两个：</p>
<ul>
<li>即使T是整数类型，这个</li>
</ul>
<pre><code class="language-cpp">undeclared(); // error if not declared (even if discarded)
</code></pre>
<p>没有声明的调用也是错的，因为它依赖模板参数</p>
<ul>
<li>这个静态断言</li>
</ul>
<pre><code class="language-cpp">static_assert(false, &quot;no integral&quot;);
</code></pre>
<p>总是失败，即使它所在的分支会被丢弃，原因还是因为它依赖一个模板参数。重复编译期条件的静态断言是可以的：</p>
<pre><code class="language-cpp">static_assert(!std::is_integral_v&lt;T&gt;, &quot;no integral&quot;);
</code></pre>
<p>注意，一些编译器（比如Visual C++2013和1025）没有正确的实现两阶段模板翻译，它们把绝大多第一阶段（<strong>definition time</strong>）该做的事情推迟到第二阶段（<strong>instantiation time</strong>），所以无效的函数调用，甚至一些语法错误也可能通过编译。</p>
<h2 id="102-使用编译期if"><a class="header" href="#102-使用编译期if">10.2 使用编译期if</a></h2>
<p>原则上，你可以使用编译器if做一些事情，看起来就像是运行时的if，只是条件是编译期的表达式。你也可以混用编译期间if和运行时if：</p>
<pre><code class="language-cpp">if constexpr (std::is_integral_v&lt;std::remove_reference_t&lt;T&gt;&gt;) {
    if (val &gt; 10) {
        if constexpr (std::numeric_limits&lt;char&gt;::is_signed) {
            ...
        }
        else {
            ...
        }
    }
    else {
        ...
    }
}
else {
    ...
}
</code></pre>
<p>注意你不能在函数体外面使用<code>if constexpr</code>。因此，你不能在用它代替条件预处理器。</p>
<h3 id="1021-编译期if注意事项"><a class="header" href="#1021-编译期if注意事项">10.2.1 编译期if注意事项</a></h3>
<p>即使有时看起来可以使用编译期if，有一些不明显的结果会出现，本小节会一一称述。</p>
<h4 id="编译期if影响返回类型"><a class="header" href="#编译期if影响返回类型">编译期if影响返回类型</a></h4>
<p>编译期if可能影响函数的返回类型。比如，下面的代码总是可以编译，但是返回类型可能是不同的：</p>
<pre><code class="language-cpp">auto foo()
{
    if constexpr (sizeof(int) &gt; 4) {
        return 42;
    }
    else {
        return 42u;
    }
}
</code></pre>
<p>因为我们用了auto，返回类型取决于返回语句，返回语句又取决于int的大小：</p>
<ul>
<li>如果size大于4，只有一个有效的返回语句返回42，所以返回类型是_int_</li>
<li>否则，只有一个有效的返回语句返回42u，所以返回类型是_unsigned int_</li>
</ul>
<p>事情还可能更魔幻。比如下面的例子，如果我们跳过else部分，返回类型可能是int或者void：</p>
<pre><code class="language-cpp">auto foo() // return type might be int or void
{
    if constexpr (sizeof(int) &gt; 4) {
        return 42;
    }
}
</code></pre>
<p>如果这里的if运行时if那代码就不能编译，因为两个返回语句都会被编译器考虑，最后得出的结论是返回类型存在二义性。</p>
<h4 id="即便then返回了else也可能造成问题"><a class="header" href="#即便then返回了else也可能造成问题">即便then返回了，else也可能造成问题</a></h4>
<p>对于运行时if语句，有一\种模式不适用于编译期if：如果then和else都有返回语句，而且能通过编译，你总是可以跳过运行时if的else部分。换句话说，下面这种代码：</p>
<pre><code class="language-cpp">if (...) {
    return a;
}
else {
    return b;
}
</code></pre>
<p>你总是可以改写为：</p>
<pre><code class="language-cpp">if (...) {
    return a;
}
return b;
</code></pre>
<p>这种模式不适用于编译期if，因为第二种形式的返回值取决于两个返回语句，而不是一个，可能会造成歧义。比如，改一下上面的例子，代码可能能编，也可能不能编：</p>
<pre><code class="language-cpp">auto foo()
{
    if constexpr (sizeof(int) &gt; 4) {
        return 42;
    }
    return 42u;
}
</code></pre>
<p>如果条件是true，那么编译器推导出两个不同的返回类型，编不了。否则，只有一个返回语句，不会造成问题，所以可以编译。</p>
<h4 id="编译期if的短路运算"><a class="header" href="#编译期if的短路运算">编译期if的短路运算</a></h4>
<p>考虑下面的代码：</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
constexpr auto foo(const T&amp; val)
{
    if constexpr (std::is_integral&lt;T&gt;::value) {
        if constexpr (T{} &lt; 10) {
            return val * 2;
        }
    }
    return val;
}
</code></pre>
<p>我们有两个编译期条件，来决定是否直接返回val，或者翻倍再返回。
下面代码都可以编译：</p>
<pre><code class="language-cpp">constexpr auto x1 = foo(42);   //产生84
constexpr auto x2 = foo(&quot;hi&quot;); //可以的，产生&quot;hi&quot;
</code></pre>
<p>在运行时if中的条件可以进行短路运算。你可能期望编译其if也有这种能力：</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
constexpr auto bar(const T&amp; val)
{
    if constexpr (std::is_integral&lt;T&gt;::value &amp;&amp; T{} &lt; 10) {
        return val * 2;
    }
    return val;
}
</code></pre>
<p>然而，编译期if的条件总是被实例化，需要作为整体来确定是否有效，所以传入一个不支持<code>&lt;10</code>判断的类型编不了：</p>
<pre><code class="language-cpp">constexpr auto x2 = bar(&quot;hi&quot;); // compile-time ERROR
</code></pre>
<p>所以，编译期if是不会短路实例化的。如果编译期条件的有效性取决于更早期的编译期条件，你不得不嵌套一下，也就是说，你不得不这样写：</p>
<pre><code class="language-cpp">if constexpr (std::is_same_v&lt;MyType, T&gt;) {
    if constexpr (T::i == 42) {
        ...
    }
}
</code></pre>
<p>而不是：</p>
<pre><code class="language-cpp">if constexpr (std::is_same_v&lt;MyType, T&gt; &amp;&amp; T::i == 42) {
    ...
}
</code></pre>
<h3 id="1022-其他编译期if的例子"><a class="header" href="#1022-其他编译期if的例子">10.2.2 其他编译期if的例子</a></h3>
<h4 id="返回完美转发"><a class="header" href="#返回完美转发">返回完美转发</a></h4>
<p>一个编译期if的应用是返回值的完美转发。因为<code>decltype(auto)</code>不能被推导为void（因为void是不完全类型（incomplete type）），你必须这样写：</p>
<pre><code class="language-cpp">#include &lt;functional&gt; // for std::forward()
#include &lt;type_traits&gt; // for std::is_same&lt;&gt; and std::invoke_result&lt;&gt;

template&lt;typename Callable, typename... Args&gt;
decltype(auto) call(Callable op, Args&amp;&amp;... args)
{

    if constexpr(std::is_void_v&lt;std::invoke_result_t&lt;Callable, Args...&gt;&gt;) {
        // return type is void:
        op(std::forward&lt;Args&gt;(args)...);
        ... // do something before we return
        return;
    }
    else {
        // return type is not void:
        decltype(auto) ret{op(std::forward&lt;Args&gt;(args)...)};
        ... // do something (with ret) before we return
        return ret;
    }
}
</code></pre>
<h4 id="编译期的tag派发"><a class="header" href="#编译期的tag派发">编译期的tag派发</a></h4>
<p>编译期if的一个传统应用是tag派发。在C++17之前，你必为你希望处理的类型提供完整的函数重载集合。现在有了编译期if，你可以把所有逻辑放到一个函数里面。举个例子，你可以不用像下面这样写一堆重载函数来实现<code>std::advance()</code>算法：</p>
<pre><code class="language-cpp">template&lt;typename Iterator, typename Distance&gt;
void advance(Iterator&amp; pos, Distance n) {
    using cat = std::iterator_traits&lt;Iterator&gt;::iterator_category;
    advanceImpl(pos, n, cat); // tag dispatch over iterator category
}
template&lt;typename Iterator, typename Distance&gt;
void advanceImpl(Iterator&amp; pos, Distance n,
    std::random_access_iterator_tag) {
    pos += n;
}
template&lt;typename Iterator, typename Distance&gt;
void advanceImpl(Iterator&amp; pos, Distance n,
                 std::bidirectional_iterator_tag) {
    if (n &gt;= 0) {
        while (n--) {
            ++pos;
        }
    }
    else {
        while (n++) {
            --pos;
        }
    }
}
template&lt;typename Iterator, typename Distance&gt;
void advanceImpl(Iterator&amp; pos, Distance n,                 std::input_iterator_tag) {
    while (n--) {
        ++pos;
    }
}
</code></pre>
<p>而是将所有行为在一个函数里面实现：</p>
<pre><code class="language-cpp">template&lt;typename Iterator, typename Distance&gt;
void advance(Iterator&amp; pos, Distance n) {
    using cat = std::iterator_traits&lt;Iterator&gt;::iterator_category;
    
    if constexpr (std::is_same_v&lt;cat,                       std::random_access_iterator_tag&gt;) {
        pos += n;
    }
    else if constexpr (std::is_same_v&lt;cat,
                       std::bidirectional_access_iterator_tag&gt;) {
        if (n &gt;= 0) {
            while (n--) {
                ++pos;
            }
        }
        else {
            while (n++) {
                --pos;
            }
        }
    }
    else { // input_iterator_tag
        while (n--) {
            ++pos;
        }
    }
}
</code></pre>
<p>在某种程度上，我们现在有一个编译期switch，虽然不同case是通过<code>if constexpr</code>来表达。注意，这里有一个区别：</p>
<ul>
<li>重载函数集合给你最佳匹配（best match）语意</li>
<li>编译期if给你第一匹配（fisrt match）语意</li>
</ul>
<p>另一个tag派发的例子是第一章里面使用编译期if的<code>get&lt;&gt;()</code>重载。
第三个例子是第十六章里面处理不同类型的<code>std::variant&lt;&gt;()</code>访问器。</p>
<h2 id="103-编译期if初始化"><a class="header" href="#103-编译期if初始化">10.3 编译期if初始化</a></h2>
<p>注意编译期if也可以用于新的带初始化的if语法中。比如，如果有个constexpr函数<code>foo()</code>，你可以使用：</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
void bar(const T x)
{
    if constexpr (auto obj = foo(x); std::is_same_v&lt;decltype(obj), T&gt;) {
        std::cout &lt;&lt; &quot;foo(x) yields same type\n&quot;;
        ...
    }
    else {
        std::cout &lt;&lt; &quot;foo(x) yields different type\n&quot;;
        ...
    }
}
</code></pre>
<p>你可以像上面一样让bar根据foo产生结果的值的类型是否与T相同，来产生不同的行为。
要根据<code>foo(x)</code>返回的值本身来决定不同行为，你可以这样：</p>
<pre><code class="language-cpp">constexpr auto c = ...;
if constexpr (constexpr auto obj = foo(c); obj == 0) {
    std::cout &lt;&lt; &quot;foo() == 0\n&quot;;
    ...
}
</code></pre>
<p><code>obj</code>必须声明为constexpr，因为要在条件中使用它的值。</p>
<h2 id="104-在模板外面使用编译期if"><a class="header" href="#104-在模板外面使用编译期if">10.4 在模板外面使用编译期if</a></h2>
<p><code>if constexpr</code>可以被用于任何函数，不仅仅局限于模板。我们只需要编译期表达式产生的结果可以转换为bool值。然而，在那种情况下then和else的中的所有语句都必须是有效地，即便它们可能被抛弃。</p>
<p>比如，下面的代码总是不能编译，因为即便char是signed、else被抛弃，<code>undeclared()</code>这个调用也必须有效才行：</p>
<pre><code class="language-cpp">#include &lt;limits&gt;

template&lt;typename T&gt;
void foo(T t);

int main()
{
    if constexpr(std::numeric_limits&lt;char&gt;::is_signed) {
        foo(42); // OK
    }
    else {
        undeclared(42); // ALWAYS ERROR if not declared (even if discarded)
    }
}
</code></pre>
<p>下面的代码也不能编译，因为其中一个静态断言总是会失败：</p>
<pre><code class="language-cpp">if constexpr(std::numeric_limits&lt;char&gt;::is_signed) {
    static_assert(std::numeric_limits&lt;char&gt;::is_signed);
}
else {
    static_assert(!std::numeric_limits&lt;char&gt;::is_signed);
}
</code></pre>
<p>在模板代码外面使用编译期if唯一的好处是那些被抛弃的语句（必须有效）不需要编到最后的二进制代码中，减小了可执行程序的体积。比如下面的程序：</p>
<pre><code class="language-cpp">#include &lt;limits&gt;
#include &lt;string&gt;
#include &lt;array&gt;
int main()
{
    if (!std::numeric_limits&lt;char&gt;::is_signed) {
        static std::array&lt;std::string,1000&gt; arr1;
        ...
    }
    else {
        static std::array&lt;std::string,1000&gt; arr2;
        ...
    }
}
</code></pre>
<p>arr1或者arr2是最终可执行程序的一部分，但不会都是。</p>
<h2 id="105-后记"><a class="header" href="#105-后记">10.5 后记</a></h2>
<p>编译期if最初由Walter Bright，Herb Sutter和Andrei Alexandrescu在<a href="https://wg21.link/n3329">https://wg21.link/n3329</a>中提出。Ville Voutilainen在<a href="https://wg21.link/n446">https://wg21.link/n4461</a>提出了static if语言特性。在<a href="https://wg21.link/p0128r0">https://wg21.link/p0128r0</a>中Ville Voutilainen第一次提出了constexpr_if（这个feature名字的起源）。最后的公认措辞是由Jens Maurer在<a href="https://wg21.link/p0292r2">https://wg21.link/p0292r2</a>中给出。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part2/cp9.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../part2/cp11.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part2/cp9.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../part2/cp11.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
