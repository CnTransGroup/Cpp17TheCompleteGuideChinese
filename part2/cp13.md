# 第十三章 auto作为模板参数占位符
从C++17开始，你可以使用占位符类型（`auto`和`decltype(auto)`作为非类型模板参数。这意味着我们可以针对不同类型的非模板参数写泛型代码。

## 13.1 使用auto作为模板参数
从C++17开始，你可以使用auto来声明一个非类型模板参数。比如：
```cpp
template<auto N> class S {
    ...
};
```
这允许我们针对不同类型都可以实例化非类型模板参数N：
```cpp
S<42> s1; // OK: type of N in S is int
S<'a'> s2; // OK: type of N in S is char
```
然而，对于那些规则不允许的类型作为模板类型，这个特性仍然是没用的，即不会实例化成功：
```cpp
S<2.5> s3; // ERROR: template parameter type still cannot be double
```
我们甚至在偏特化中可以写具体类型：
```cpp
template<int N> class S<N> {
    ...
};
```
甚至支持类模板参数推导。比如：
```cpp
template<typename T, auto N>
class A {
public:
    A(const std::array<T,N>&) {
    }
    A(T(&)[N]) {
    }
    ...
};
```
可以推导T的类型，N的类型，N的值。：
```cpp
A a2{"hello"}; // OK, deduces A<const char, 6> with N being int

std::array<double,10> sa1;
A a1{sa1}; // OK, deduces A<double, 10> with N being std::size_t
```
你也可以修饰`auto`，比如，要求模板参数的类型是一个指针：
```cpp
template<const auto* P> struct S;
```
使用可变参数模板，你可以参数化模板，使用一堆同构模板参数：
```cpp
template<auto... VS> class HeteroValueList {
};
```
或者一堆异构模板参数：
```cpp
template<auto V1, decltype(V1)... VS> class HomoValueList {
};
```
比如：
```cpp
HeteroValueList<1, 2, 3> vals1; // OK
HeteroValueList<1, 'a', true> vals2; // OK
HomoValueList<1, 2, 3> vals3; // OK
HomoValueList<1, 'a', true> vals4; // ERROR
```

### 13.1.1 参数化模板以适用字符和字符串
使用该特性的一种应用是允许同时传入字符和字符串作为模板参数。比如我们可以使用折叠表达式输出任意数量的参数的个数：
```cpp
#include <iostream>

template<auto Sep = ' ', typename First, typename... Args>
void print(const First& first, const Args&... args) {
    std::cout << first;
    auto outWithSep = [](const auto& arg) {
                        std::cout << Sep << arg;
                      };
    (... , outWithSep(args));
    std::cout << '\n';
}
```
使用空格作为模板参数的一个默认参数，我们可以输出带空格分隔的参数：
```cpp
template<auto Sep = ' ', typename First, typename... Args>
void print (const First& firstarg, const Args&... args) {
    ...
}
```
我们仍然可以调用：
```cpp
std::string s{"world"};
print(7.5, "hello", s); // prints: 7.5 hello world
```
但是有了参数化的`print()`，而且带分隔符**Sep**，我们现在可以显式的传递一个不同的字符作为第一个模板参数：
```cpp
print<' '>(7.5, "hello", s); // prints: 7.5-hello-world
```
因为用了`auto`，我们甚至可以传一个字符串字面值，但这样的话就不得不声明一个没有链接（linkage）的对象：
```cpp
static const char sep[] = ", ";
print<sep>(7.5, "hello", s); // prints: 7.5, hello, world
```
或者我们可以传一个分隔符，只要类型是允许作为模板参数的：
```cpp
print<-11>(7.5, "hello", s); // prints: 7.5-11hello-11world
```