<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第十五章 std::optional&lt;&gt; - C++ 17 The Complete Guide</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../part1/index.html">第一部分 基本语言特性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../part1/cp1.html">第一章 结构化绑定</a></li><li class="chapter-item "><a href="../part1/cp2.html">第二章 带初始化的if和switch</a></li><li class="chapter-item "><a href="../part1/cp3.html">第三章 内联变量</a></li><li class="chapter-item "><a href="../part1/cp4.html">第四章 聚合扩展</a></li><li class="chapter-item "><a href="../part1/cp5.html">第五章 强制拷贝消除或者传递未具体化对象</a></li><li class="chapter-item "><a href="../part1/cp6.html">第六章 Lambda扩展</a></li><li class="chapter-item "><a href="../part1/cp7.html">第七章 新属性和属性相关特性</a></li><li class="chapter-item "><a href="../part1/cp8.html">第八章 其他语言特性</a></li></ol></li><li class="chapter-item expanded "><a href="../part2/index.html">第二部分 模板特性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../part2/cp9.html">第九章 类模板参数推导</a></li><li class="chapter-item "><a href="../part2/cp10.html">第十章 编译期if</a></li><li class="chapter-item "><a href="../part2/cp11.html">第十一章 折叠表达式</a></li><li class="chapter-item "><a href="../part2/cp12.html">第十二章 String作为模板参数</a></li><li class="chapter-item "><a href="../part2/cp13.html">第十三章 auto作为模板参数占位符</a></li><li class="chapter-item "><a href="../part2/cp14.html">第十四章 扩展Using声明</a></li></ol></li><li class="chapter-item expanded "><div>第三部分 新的标准库组件</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part3/cp15.html" class="active">第十五章 std::optional&lt;&gt;</a></li><li class="chapter-item "><div>第十六章 std::variant&lt;&gt;</div></li><li class="chapter-item "><div>第十七章 std::any</div></li><li class="chapter-item "><div>第十八章 std::byte</div></li><li class="chapter-item "><div>第十九章 String View</div></li><li class="chapter-item "><div>第二十章 文件系统库</div></li></ol></li><li class="chapter-item expanded "><div>第四部分 标准库扩展和修改</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>第二十一章 Type Trait扩展</div></li><li class="chapter-item "><div>第二十二章 并行STL算法</div></li><li class="chapter-item "><div>第二十三章 子字符串和子序列搜索</div></li><li class="chapter-item "><div>第二十四章 其他工具函数和算法</div></li><li class="chapter-item "><div>第二十五章 容器扩展</div></li><li class="chapter-item "><div>第二十六章 多线程和兵法</div></li></ol></li><li class="chapter-item expanded "><div>第五部分 专业工具</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>第二十七章 多态类型资源（PMR）</div></li><li class="chapter-item "><div>第二十八章 对齐数据上的new和delete</div></li><li class="chapter-item "><div>第二十九章 其他专业库的改动</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ 17 The Complete Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CnTransGroup/Cpp17TheCompleteGuideChinese" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第十五章-stdoptional"><a class="header" href="#第十五章-stdoptional">第十五章 <code>std::optional&lt;&gt;</code></a></h1>
<p>编程的时候我们经常遇到的一个情况是<strong>可能</strong>需要返回/传递/使用某个对象。也就是说，我们可能要获取某个类型的值，也可能完全不获取。因此，我们需要一种方式来模拟这种类似指针的语义，当不需要值的时候给它传<strong>nullptr</strong>。处理这种情况的通常方式是定义一个类型，里面包含了值本身，同时还带一个布尔值的成员（或者说flag）来标示值是否存在。</p>
<p>**可空对象(Optional objects)**就是这样的，它的内部内存主要包含一个对象加上一个布尔类型的flag。因此，它的大小通常是比包含的对象要大一个字节。对于某些包含的对象，鉴于额外的信息可以放到包含的对象里面，可空对象本身甚至可以做到零额外开销。不会分配内存。可空对象和被包含的对象完全一致。</p>
<p>然而，可空对象不仅仅是在结构布局上比普通对象多了个布尔值的flag。举个例子，如果没有值，那么被包含对象的构造函数也不会被调用（因此，这种情况下你可以给这些对象填充一个默认的状态）。</p>
<p>如同<code>std::variant&lt;&gt;</code>和<code>std::any</code>对象一样，可控对象也有值语义。也即是说，拷贝操作的底层实现是<em>深拷贝</em>，会创建一个完全不同的被包含的对象的副本以及布尔flag。拷贝不带包含值的<code>std::optional&lt;&gt;</code>可选对象开销非常小。拷贝一个带包含值的<code>std::optional&lt;&gt;</code>开销大不大完全取决于拷贝这个包含值。另外可空对象也支持移动语义。</p>
<h2 id="151-使用stdoptional"><a class="header" href="#151-使用stdoptional">15.1 使用<code>std::optional&lt;&gt;</code></a></h2>
<p><code>std::optional&lt;&gt;</code>塑造了一个可容纳类型的、可空的对象。这个对象可以是成员，也可以是实参，又或者返回值。你也可以说<code>std::optional&lt;&gt;</code>是一个容器，容纳最多一个元素（译注：最少零个）。</p>
<h3 id="1511-可空的返回值"><a class="header" href="#1511-可空的返回值">15.1.1 可空的返回值</a></h3>
<p>下面的程序演示了<code>std::optional&lt;&gt;</code>用来作为返回值的能力：</p>
<pre><code class="language-cpp">#include &lt;optional&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

// convert string to int if possible:
std::optional&lt;int&gt; asInt(const std::string&amp; s)
{
    try {
        return std::stoi(s);
    }
    catch (...) {
        return std::nullopt;
    }
}
int main()
{
    for (auto s : {&quot;42&quot;, &quot; 077&quot;, &quot;hello&quot;, &quot;0x33&quot;} ) {
        // try to convert s to int and print the result if possible:
        std::optional&lt;int&gt; oi = asInt(s);
        if (oi) {
            std::cout &lt;&lt; &quot;convert '&quot; &lt;&lt; s &lt;&lt; &quot;' to int: &quot; &lt;&lt; *oi &lt;&lt; &quot;\n&quot;;
        }
        else {
            std::cout &lt;&lt; &quot;can't convert '&quot; &lt;&lt; s &lt;&lt; &quot;' to int\n&quot;;
        }
    }
}
</code></pre>
<p>程序里面<code>asInt()</code>这个函数将传过来的字符串转换为一个int值。然而，这可能会失败。出于这个原因，我们用<code>std::optional&lt;&gt;</code>，这样我们就可以返回“无int”并且避免了用一个特殊int值表示失败或者给调用者抛一个异常。</p>
<p>因此，我们既可以调用<code>stoi()</code>来初始化可空对象，也可以返回<code>std::nullopt</code>，告诉调用者我们没有int要返回给你。我们可以用下面的代码实现相同的行为：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; asInt(const std::string&amp; s)
{
    std::optional&lt;int&gt; ret; // initially no value
    try {
        ret = std::stoi(s);
    }
    catch (...) {
    }
    return ret;
}
</code></pre>
<p>在<code>main()</code>中我们调用这个函数，然后传给它不同的字符串：</p>
<pre><code class="language-cpp">for (auto s : {&quot;42&quot;, &quot; 077&quot;, &quot;hello&quot;, &quot;0x33&quot;} ) {
    // convert s to int and use the result if possible:
    std::optional&lt;int&gt; oi = asInt(s);
    ...
}
</code></pre>
<p>对于每个返回的<code>std::optional&lt;int&gt; oi</code>，我们都要检查一下是否有值（通过查布尔flag得知）然后通过对可空对象“解引用”来访问被包含的对象：</p>
<pre><code class="language-cpp">if (oi) {
    std::cout &lt;&lt; &quot;convert '&quot; &lt;&lt; s &lt;&lt; &quot;' to int: &quot; &lt;&lt; *oi &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<p>注意字符串“0x33”调用<code>asInt()</code>拿到了0，因为<code>stoi()</code>不对十六进制字符串做解析。
还有一只可选的方式来实现返回值处理：</p>
<pre><code class="language-cpp">if (oi.has_value()) {
    std::cout &lt;&lt; &quot;convert '&quot; &lt;&lt; s &lt;&lt; &quot;' to int: &quot; &lt;&lt; oi.value() &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<p>这里，<code>has_value()</code>用于检查可空对象是否包含值，然后用<code>value()</code>访问值。<code>value()</code>比<code>operator *</code>更安全：如果没有值，它抛出异常（译注：而不是对空对象解引用产生段错误）。<code>operator *</code>应该只被用于那种你非常确信可空对象不是空的的场景。否则你的程序将产生<strong>未定义行为(undefined behavior)</strong>。
注意我们也可以使用新标准库类型<code>std::string_view</code>来优化<code>asInt()</code>。</p>
<h3 id="1512-可空对象作为实参和对象成员"><a class="header" href="#1512-可空对象作为实参和对象成员">15.1.2 可空对象作为实参和对象成员</a></h3>
<p>另一个使用<code>std::optional&lt;&gt;</code>的例子是传实参并且/或者将它作为对象的数据成员：</p>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;optional&gt;
#include &lt;iostream&gt;

class Name
{
    private:
        std::string first;
        std::optional&lt;std::string&gt; middle;
        std::string last;
    public:
        Name (std::string f,
              std::optional&lt;std::string&gt; m,
              std::string l)
          : first{std::move(f)}, middle{std::move(m)}, last{std::move(l)} {
        }
        friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; strm, const Name&amp; n) {
            strm &lt;&lt; n.first &lt;&lt; ' ';
            if (n.middle) {
                strm &lt;&lt; *n.middle &lt;&lt; ' ';
            }
            return strm &lt;&lt; n.last;
        }
};

int main()
{
    Name n{&quot;Jim&quot;, std::nullopt, &quot;Knopf&quot;};
    std::cout &lt;&lt; n &lt;&lt; '\n';
    Name m{&quot;Donald&quot;, &quot;Ervin&quot;, &quot;Knuth&quot;};
    std::cout &lt;&lt; m &lt;&lt; '\n';
}
</code></pre>
<p>类<strong>Name</strong>表示名字，由<strong>first name</strong>、<strong>middle name</strong>和<strong>last name</strong>三个成员组成。由于<strong>middle name</strong>有可能不存在，因此它被定义为可空对象，这样构造函数就可以传一个<code>std::nullopt</code>来表示没有<strong>middle name</strong>。这和<strong>middle name</strong>是空字符串是不一样的。</p>
<p>注意通常类型都带值语义，定义一个初始化对应成员的构造函数的最好方式是实参值传递，然后构造函数里面移动形参到成员。</p>
<p>还有一点也要注意，<code>std::optional&lt;&gt;</code>改变了<strong>middle name</strong>的访问方式。将<strong>middle</strong>作为布尔表达式可以知道是否存在<strong>middle name</strong>，不过要想访问它的值还是得<code>*middle</code>（如果有的话）。</p>
<p>另一种访问可空对象包含的值的方式是使用成员函数<code>value_or()</code>，它可以指定一个备选值，当可空对象真的空的时候这个备选值将作为结果。举个例子，我们可以这样做：</p>
<pre><code class="language-cpp">std::cout &lt;&lt; middle.value_or(&quot;&quot;); // print middle name or nothing
</code></pre>
<h2 id="152-stdoptional类型和操作"><a class="header" href="#152-stdoptional类型和操作">15.2 <code>std::optional&lt;&gt;</code>类型和操作</a></h2>
<p>这一小节描述了<code>std::optional&lt;&gt;</code>的类型和操作细节。</p>
<h3 id="1521-stdoptional类型"><a class="header" href="#1521-stdoptional类型">15.2.1 <code>std::optional&lt;&gt;</code>类型</a></h3>
<p>在C++标准库头文件<code>&lt;optional&gt;</code>使用下面的形式定义<code>std::optional&lt;&gt;</code>：</p>
<pre><code class="language-cpp">namespace std{
    template&lt;typename T&gt; class optional;
}
</code></pre>
<p>另外，还定义了下面的对象和对象：</p>
<ul>
<li>定义了<strong>nullopt</strong>对象，它的类型是<code>std::nullopt_t</code>，它表示可空对象没有值</li>
<li>定义了异常类<code>std::bad_optional_access</code>，继承自<code>std::exception</code>，如果访问空的可空对象将引发此异常。</li>
</ul>
<h3 id="1522-stdoptional操作"><a class="header" href="#1522-stdoptional操作">15.2.2 <code>std::optional&lt;&gt;</code>操作</a></h3>
<p>下表列出了针对<code>std::optional&lt;&gt;</code>的所有操作。</p>
<h4 id="构造"><a class="header" href="#构造">构造</a></h4>
<p>特殊的构造函数可以直接传递包含的值作为构造函数参数：</p>
<ul>
<li>你可以创建一个空的可空对象。</li>
</ul>
<pre><code class="language-cpp">std::optional&lt;int&gt; o1;
std::optional&lt;int&gt; o2(std::nullopt);
</code></pre>
<ul>
<li>你可以传值来初始化可空对象里面包含的对象。因为<a href="part2/cp9.html">类模板参数推导规则</a>，你不用非得指定包含对象的类型：</li>
</ul>
<pre><code class="language-cpp">std::optional o3{42}; // deduces optional&lt;int&gt;
std::optional&lt;std::string&gt; o4{&quot;hello&quot;};
std::optional o5{&quot;hello&quot;}; // deduces optional&lt;const char*&gt;
</code></pre>
<table><thead><tr><th style="text-align: center">操作</th><th style="text-align: center">效果</th></tr></thead><tbody>
<tr><td style="text-align: center">构造</td><td style="text-align: center">创建一个可空对象（可能会调用包含的对象的构造函数）</td></tr>
<tr><td style="text-align: center"><code>make_optional&lt;&gt;()</code></td><td style="text-align: center">创建一个可空对象（传值初始化它</td></tr>
<tr><td style="text-align: center">析构函数</td><td style="text-align: center">销毁可空对象</td></tr>
<tr><td style="text-align: center"><code>=</code></td><td style="text-align: center">赋新值</td></tr>
<tr><td style="text-align: center"><code>emplace()</code></td><td style="text-align: center">给包含的对象赋新值</td></tr>
<tr><td style="text-align: center"><code>reset()</code></td><td style="text-align: center">销毁值（让可空对象变空）</td></tr>
<tr><td style="text-align: center"><code>has_value()</code></td><td style="text-align: center">可空对象是否为空</td></tr>
<tr><td style="text-align: center">强制类型转换为bool</td><td style="text-align: center">可空对象是否为空</td></tr>
<tr><td style="text-align: center"><code>*</code></td><td style="text-align: center">访问被包含的值（如果可空对象为空的时候执行该操作会产生未定义行为）</td></tr>
<tr><td style="text-align: center"><code>-&gt;</code></td><td style="text-align: center">访问被包含的值（如果可空对象为空的时候执行该操作会产生未定义行为）</td></tr>
<tr><td style="text-align: center"><code>value()</code></td><td style="text-align: center">访问被包含的值（如果可空对象为空的时候执行该操作会引发异常）</td></tr>
<tr><td style="text-align: center"><code>value_or()</code></td><td style="text-align: center">访问被包含的值（如果可空对象为空的时候执行该操作会返回备选值）</td></tr>
<tr><td style="text-align: center"><code>swap()</code></td><td style="text-align: center">交换两个可空对象</td></tr>
<tr><td style="text-align: center"><code>==,!=,&lt;,&lt;=,&gt;,&gt;=</code></td><td style="text-align: center">比较两个可空对象</td></tr>
<tr><td style="text-align: center"><code>hash&lt;&gt;</code></td><td style="text-align: center">计算两个可空对象的哈希值</td></tr>
</tbody></table>
<ul>
<li>要用多个值初始化可空对象，你必须直接创建该对象，或者<code>std::in_place</code>作为第一个参数然后传递剩下的值（因为被包含的类型不能推导）：</li>
</ul>
<pre><code class="language-cpp">std::optional o6{std::complex{3.0, 4.0}};
std::optional&lt;std::complex&lt;double&gt;&gt; o7{std::in_place, 3.0, 4.0};
</code></pre>
<p>注意第二种形式避免了临时对象的创建。使用这种形式你甚至可以传递一个initializer list再加上额外的参数：</p>
<pre><code class="language-cpp">// initialize set with lambda as sorting criterion:
auto sc = [] (int x, int y) {
    return std::abs(x) &lt; std::abs(y);
};
std::optional&lt;std::set&lt;int,decltype(sc)&gt;&gt; o8    {std::in_place,
                                                {4, 8, -7, -2, 0, 5},
                                                sc};
</code></pre>
<ul>
<li>你可以拷贝可空对象</li>
</ul>
<pre><code class="language-cpp">std::optional o5{&quot;hello&quot;}; // deduces optional&lt;const char*&gt;
std::optional&lt;std::string&gt; o9{o5}; // OK
</code></pre>
<p>注意还有一个便捷函数<code>make_optional&lt;&gt;()</code>，它允许你用一个或者多个参数初始化可空对象（不需要<code>in_place</code>作为第一个参数）。通常用<code>make...</code>系列函数都会导致类型退化（译注：decay）：</p>
<pre><code class="language-cpp">auto o10 = std::make_optional(3.0); // optional&lt;double&gt;
auto o11 = std::make_optional(&quot;hello&quot;); // optional&lt;const char*&gt;
auto o12 = std::make_optional&lt;std::complex&lt;double&gt;&gt;(3.0, 4.0);
</code></pre>
<p>但是请注意没有构造函数可以根据一个参数来推导他的类型，不管可空对象初始化带不带值。因此，必须使用<code>operator ？</code>。举个例子：</p>
<pre><code class="language-cpp">std::multimap&lt;std::string, std::string&gt; englishToGerman;
...
auto pos = englishToGerman.find(&quot;wisdom&quot;);
auto o13 = pos != englishToGerman.end()
            ? std::optional{pos-&gt;second}
            : std::nullopt;
</code></pre>
<p>因为<a href="part2/cp9.html">类模板参数推导规则</a>，<code>std::optional{pos-&gt;second}</code>将<strong>o13</strong>被初始化为<code>std::optional&lt;std::string&gt;</code>类型。对于<code>std::nullopt</code>，模板类型推导无法正常工作，但是在推导表达式最终类型的时候<code>operator ?</code>可以将它转换为这个类型。</p>
<h4 id="访问值"><a class="header" href="#访问值">访问值</a></h4>
<p>要检查可空对象是不是空的，你可以将它作为布尔表达式或者调用<code>has_value()</code>函数：</p>
<pre><code class="language-cpp">std::optional o{42};

if (o) ... // true
if (!o) ... // false
if (o.has_value()) ... // true
</code></pre>
<p>接下来要访问值，可以用类似指针的语法。你可以直接用<code>operator *</code>访问包含的对象，用<code>operator-&gt;</code>访问包含的对象的成员：</p>
<pre><code class="language-cpp">std::optional o{std::pair{42, &quot;hello&quot;}};

auto p = *o; // initializes p as pair&lt;int,string&gt;
std::cout &lt;&lt; o-&gt;first; // prints 42
</code></pre>
<p>注意这些操作都要求可空对象本身不为空。如果可空对象为空又执行这些操作将会产生未定义行为：</p>
<pre><code class="language-cpp">std::optional&lt;std::string&gt; o{&quot;hello&quot;};
std::cout &lt;&lt; *o; // OK: prints &quot;hello&quot;
o = std::nullopt;
std::cout &lt;&lt; *o; // undefined behavior
</code></pre>
<p>虽然第二个是未定义行为，但是实践中它很可能会通过编译并且执行结果和第一个一样，都输出&quot;hello&quot;，因为可空对象管理的内存没有被修改。
然而，你不能，也不应该依赖这个。如果你不知道可空对象是不是空的，那么请事先检查：</p>
<pre><code class="language-cpp">if (o) std::cout &lt;&lt; *o; // OK (might output nothing)
</code></pre>
<p>或者你可以用<code>value()</code>检查，它会跑抛出<code>std::bad_optional_access_exception</code>：</p>
<pre><code class="language-cpp">std::cout &lt;&lt; o.value(); // OK (throws if no value)
</code></pre>
<p><code>std::bad_optional_access_exception</code>直接继承自<code>std::exception</code>。
最后，你可以在检查是否为空的时候传一个备选值，如果可空对象真的是空的那么将返回这个备选值：</p>
<pre><code class="language-cpp">std::cout &lt;&lt; o.value_or(&quot;fallback&quot;); // OK (outputs fallback if no value)
</code></pre>
<p>备选值是通过右值引用的方式传递的，所以如果备选值没有被使用，整个传递过程零开销，如果被使用，走的是移动语义。</p>
<p>请注意<code>operator *</code>和<code>value()</code>一样都是返回的被包含的对象的引用。因此，你必须小心操作这些临时返回值。比如：</p>
<pre><code class="language-cpp">std::optional&lt;std::string&gt; getString();
...
auto a = getString().value(); // OK: copy of contained object
auto b = *getString(); // ERROR: undefined behavior if std::nullopt
const auto&amp; r1 = getString().value(); // ERROR: reference to deleted contained object
auto&amp;&amp; r2 = getString().value(); // ERROR: reference to deleted contained object
</code></pre>
<p>有时候你可能会像下面一样把它用于range-based循环中：</p>
<pre><code class="language-cpp">std::optional&lt;std::vector&lt;int&gt;&gt; getVector();
...
for (int i : getVector().value()) { // ERROR: iterate over deleted vector
    std::cout &lt;&lt; i &lt;&lt; '\n';
}
</code></pre>
<p>返回int的vector，然后迭代它是可以的。所以不要轻易的将<code>foo()</code>返回值类型改变成对应的可空类型，而应该调用<code>foo().value()</code>。</p>
<h4 id="比较"><a class="header" href="#比较">比较</a></h4>
<p>你可以使用普通的比较运算符。操作数可以是一个可空对象、被包含的对象、<code>std::nullopt</code>。</p>
<ul>
<li>如果操作数都是不为空的可空对象，将会比较被包含的值</li>
<li>如果操作数都是空的可空对象，那么比较运算会认为它们相等（<code>==</code>产生true值，其他比较运算符产生false值）</li>
<li>如果一个操作数为空，一个不为空，为空的那个操作数将会被认为是小于不为空的那个操作数</li>
</ul>
<p>比如：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; o0;
std::optional&lt;int&gt; o1{42};

    o0 == std::nullopt // yields true
    o0 == 42 // yields false
    o0 &lt; 42 // yields true
    o0 &gt; 42 // yields false
    o1 == 42 // yields true
    o0 &lt; o1 // yields true
</code></pre>
<p>这意味着对于包含unsigned int的可空对象，它可以小于零，对于包含bool的可空对象，它也可以小于零：</p>
<pre><code class="language-cpp">std::optional&lt;unsigned&gt; uo;
    uo &lt; 0 // yields true
std::optional&lt;bool&gt; bo;
    bo &lt; false // yields true
</code></pre>
<p>再次强调，包含类型的隐式类型转换是支持的：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; o1{42};
std::optional&lt;double&gt; o2{42.0};

o2 == 42 // yields true
o1 == o2 // yields true
</code></pre>
<p>另外包含bool或者原生指针的可空对象在这里会产生一些令人意外的结果。</p>
<h4 id="修改值"><a class="header" href="#修改值">修改值</a></h4>
<p>赋值操作和<code>emplace()</code>操作与初始化对应：</p>
<pre><code class="language-cpp">std::optional&lt;std::complex&lt;double&gt;&gt; o; // has no value
std::optional ox{77}; // optional&lt;int&gt; with value 77

o = 42; // value becomes complex(42.0, 0.0)
o = {9.9, 4.4}; // value becomes complex(9.9, 4.4)
o = ox; // OK, because int converts to complex&lt;double&gt;
o = std::nullopt; // o no longer has a value
o.emplace(5.5, 7.7); // value becomes complex(5.5, 7.7)
</code></pre>
<p>给可空对象赋<code>std::nullopt</code>会移除原来的包含值，即调用原包含值的析构函数。你可以用<code>reset()</code>实现一样的效果：</p>
<pre><code class="language-cpp">o.reset();  // o no longer has a value
</code></pre>
<p>或者赋给它一个<code>{}</code>：</p>
<pre><code class="language-cpp">o = {}; // o no longer has a value
</code></pre>
<p>最后，我们也可以用<code>operator *</code>修改值，因为它产生包含值的引用。然而注意前提是可空对象得有值存在：</p>
<pre><code class="language-cpp">std::optional&lt;std::complex&lt;double&gt;&gt; o;
*o = 42; // undefined behavior
...
if (o) {
    *o = 88; // OK: value becomes complex(88.0, 0.0)
    *o = {1.2, 3.4}; // OK: value becomes complex(1.2, 3.4)
}
</code></pre>
<h4 id="移动语义"><a class="header" href="#移动语义">移动语义</a></h4>
<p><code>std::optional&lt;&gt;</code>也支持移动语义。如果你将整个对象移动，状态会随之被复制，被包含的值（如果有的话）也会被移动。
结果就是，移动后的对象状态仍然还保留，但是被包含的值已经不在了。
但是你可以将一个值移动到被包含对象里面，或者从被包含对象里面移出去。比如：</p>
<pre><code class="language-cpp">std::optional&lt;std::string&gt; os;
std::string s = &quot;a very very very long string&quot;;
os = std::move(s); // OK, moves
std::string s2 = *os; // OK copies
std::string s3 = std::move(*os); // OK, moves
</code></pre>
<p>执行完最后一行，<strong>os</strong>仍然还有字符串的值，但是通常来说移动后的对象的值都是不存在的（译注：原文是unspecified）。因此，
你仍然可以使用它，前提是你不要对它是什么做任何假设。你甚至可以给它赋一个新字符串。</p>
<h4 id="哈希"><a class="header" href="#哈希">哈希</a></h4>
<p>可空对象的哈希值是被包含对象的哈希值（如果存在的话）。</p>
<h2 id="153-特殊情况"><a class="header" href="#153-特殊情况">15.3 特殊情况</a></h2>
<p>可空对象包含特定的类型可能产生令人意想不到的结果甚至未定义行为。</p>
<h3 id="1531-包含布尔值或原生指针"><a class="header" href="#1531-包含布尔值或原生指针">15.3.1 包含布尔值或原生指针</a></h3>
<p>对可空对象使用比较运算符和将它视作布尔值有不同的雨衣。如果可空对象包含布尔值或者原生指针可能会产生一些困扰：比如：</p>
<pre><code class="language-cpp">std::optional&lt;bool&gt; ob{false}; // has value, which is false
if (!ob) ... // yields false
if (ob == false) ... // yields true

std::optional&lt;int*&gt; op{nullptr};
if (!op) ... // yields false
if (op == nullptr) ... // yields true
</code></pre>
<h3 id="1532-可空对象里面包含可空对象"><a class="header" href="#1532-可空对象里面包含可空对象">15.3.2 可空对象里面包含可空对象</a></h3>
<p>原则上，你可以定义包含可空对象的可空对象：</p>
<pre><code class="language-cpp">std::optional&lt;std::optional&lt;std::string&gt;&gt; oos1;
std::optional&lt;std::optional&lt;std::string&gt;&gt; oos2 = &quot;hello&quot;;
std::optional&lt;std::optional&lt;std::string&gt;&gt;
    oos3{std::in_place, std::in_place, &quot;hello&quot;};

std::optional&lt;std::optional&lt;std::complex&lt;double&gt;&gt;&gt;
    ooc{std::in_place, std::in_place, 4.2, 5.3};
</code></pre>
<p>你也可以借助隐式转换给它赋一个新值：</p>
<pre><code class="language-cpp">oos1 = &quot;hello&quot;; // OK: assign new value
ooc.emplace(std::in_place, 7.2, 8.3);
</code></pre>
<p>两层可空对象都没有值，但是最外层可空对象和最内层可空对象有没有值有待商榷：</p>
<pre><code class="language-cpp">*oos1 = std::nullopt; // inner optional has no value
oos1 = std::nullopt; // outer optional has no value
</code></pre>
<p>你必须小心谨慎处理这些特殊例子：</p>
<pre><code class="language-cpp">if (!oos1) std::cout &lt;&lt; &quot;no value\n&quot;;
if (oos1 &amp;&amp; !*oos1) std::cout &lt;&lt; &quot;no inner value\n&quot;;
if (oos1 &amp;&amp; *oos1) std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; **oos1 &lt;&lt; '\n';
</code></pre>
<p>因为这个语义上不仅仅是说一个有两种状态的值表示没有值，使用<code>std::variant&lt;&gt;</code>包裹两个bool或者用<code>std::monostate</code>可能是更合适的选择。</p>
<h2 id="154-后记"><a class="header" href="#154-后记">15.4 后记</a></h2>
<p>可空对象首先由Fernando Cacciola在2005的<a href="https://wg21.link/n1878">https://wg21.link/n1878</a>中提出。Fernando Cacciola和Andrzej Krzemienski提出新提案<a href="https://wg21.link/n3793">https://wg21.link/n3793</a>被Library Fundamentals TS接受</p>
<p>Beman Dawes和Alisdair Meredith的新提案<a href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a>被其他C++17组件接受。</p>
<p>Tony van Eerd极大的改进了比较操作的语义，提案参见[https://
wg21.link/n3765](https://
wg21.link/n3765)和<a href="https://wg21.link/p0307r2">https://wg21.link/p0307r2</a>。 Vicente J. Botet Escriba 优化了std::optional&lt;&gt;
、std::variant&lt;&gt;和std::anyAPI，提案参见https://wg21.link/p0032r3。Jonathan Wakely修复了in_place的行为，提案参见https://wg21.link/p0504r0。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part2/cp14.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part2/cp14.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
